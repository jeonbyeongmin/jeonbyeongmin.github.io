I"l/<p><br /></p>

<p>    정렬에 대한 알고리즘은 다양하다. 빠른 속도를 보여주는 정렬은 \(O(nlogn)\)시간이 걸리는 퀵 정렬 (Quick Sort), 힙 정렬 (Heap Sort), 합병 정렬 (Merge Sort)이 있고, 그 중에서 대부분의 경우에 퀵 정렬을 쓴다고 소개했었다.
<br /></p>

<p>     하지만 오늘 설명할 <span style="color:green"> <strong>카운팅 정렬 (Counting Sort)</strong></span>의 시간복잡도는 \(O(n+k)\)이며 \(n &gt; k\)인 경우에는 퀵 정렬보다 훨씬 빠른 성능을 자랑한다.</p>

<p><br /></p>
<blockquote>
  <p>그럼 왜 대부분의 경우에서 퀵 정렬을 사용할까</p>
</blockquote>

<ol>
  <li>카운팅 정렬은 추가적인 메모리 할당이 필요하다.</li>
  <li>정렬해야하는 수의 범위를 모른다면 사용하기가 곤란하다.</li>
  <li>수열의 크기\((n)\)보다 정렬해야하는 수의 최대값\((k)\)의 가 크다면 시간이 비약적으로 증가한다.</li>
</ol>

<p><br /></p>

<h2 id="01-counting-sort의-개념과-동작과정">01. Counting Sort의 개념과 동작과정</h2>
<p><br /></p>

<p>    보통 정렬을 할 때에는 비교를 하기 마련이다. 합병 정렬도 그렇고, 퀵 정렬도 그렇고, 힙 정렬도 마찬가지이다. 이런 비교 기반 정렬법들은 어지간하면 시간 복잡도가 \(O(nlogn)\)보다 짧아지기가 어렵운데, 카운팅 정렬은 \(O(n+k)\)이다. 이게 어떻게 된 일일까.</p>

<blockquote>
  <p>Counting Sort는 비교 기반 정렬이 아니다.</p>
</blockquote>

<p>    카운팅 정렬은 기본적으로 비교 연산이 들어가는 정렬이 아니다. 카운팅 정렬의 동작 과정을 보며 카운팅 정렬의 정렬 방법을 알아보자. (변수의 이름은 밑의 애니메이션의 변수와 같으니 애니메이션을 참고하자)</p>
<ol>
  <li>먼저 카운팅 정렬은 수를 세주는 배열 <code class="language-plaintext highlighter-rouge">c[]</code>가 필요하다. 정렬이 필요한 배열 <code class="language-plaintext highlighter-rouge">a[]</code>의 각 <code class="language-plaintext highlighter-rouge">index</code>를 방문하여 <code class="language-plaintext highlighter-rouge">a[index] = k</code>일때  <code class="language-plaintext highlighter-rouge">c[k]++</code>를 해주어 <code class="language-plaintext highlighter-rouge">a</code>가 몇 번 반복되었는 세줄 것이다.</li>
  <li>실제 정렬을 했을 때 그 숫자가 처음 시작하는 <code class="language-plaintext highlighter-rouge">index</code>를 알기 위하여 <code class="language-plaintext highlighter-rouge">c[i] = c[i] + c[i-1]</code>를 통해 카운트의 누적합을 적용한다.</li>
  <li>이제 <code class="language-plaintext highlighter-rouge">a[]</code>를 아래 애니메이션과 같은 과정으로 <code class="language-plaintext highlighter-rouge">b[]</code>에 정렬해줄 것이다.</li>
</ol>

<p><img src="https://spagnuolocarmine.github.io/assets/img/count.gif" alt="" /></p>

<p><br /></p>

<h2 id="02-counting-sort-java-소스코드">02. Counting Sort JAVA 소스코드</h2>
<p><br /></p>

<p>변수의 이름은 위 설명의 변수와 같으니 설명과 애니메이션을 참고하자</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">){</span>

        <span class="kt">int</span> <span class="n">a</span><span class="o">[]</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">10</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">c</span><span class="o">[]</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">20</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">b</span><span class="o">[]</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">a</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">a</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span> <span class="c1">// 00. a에 랜덤 원소 할당</span>
            <span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)(</span><span class="nc">Math</span><span class="o">.</span><span class="na">random</span><span class="o">()*</span><span class="mi">20</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">a</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span> <span class="c1">// 01. 카운팅</span>
           <span class="n">c</span><span class="o">[</span><span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">]]++;</span>
        <span class="o">}</span>
				
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span> <span class="c1">// 02. 카운트 누적합</span>
           <span class="n">c</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">c</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="n">c</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">];</span>
        <span class="o">}</span>
				
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">--){</span> <span class="c1">// 03. 누적합를 통해 실질적인 정렬을 담당</span>
           <span class="n">c</span><span class="o">[</span><span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">]]--;</span>
           <span class="n">b</span><span class="o">[</span><span class="n">c</span><span class="o">[</span><span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">]]]</span> <span class="o">=</span> <span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
        <span class="o">}</span>


        <span class="c1">// 출력</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">a</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">" | "</span> <span class="o">+</span> <span class="n">a</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">b</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">" | "</span> <span class="o">+</span> <span class="n">b</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
        <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><br /></p>

<p>만약 단순히 정렬된 출력이 필요하다면 2번, 3번, 출력 부분을 생략하고 다음과 같은 코드로 대신하여도 된다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
            <span class="k">while</span><span class="o">(</span><span class="n">c</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">){</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
                <span class="n">count</span><span class="o">[</span><span class="n">i</span><span class="o">]--;</span>
            <span class="o">}</span>
        <span class="o">}</span>
</code></pre></div></div>

<p><br /></p>
<h2 id="03-counting-sort의-시간복잡도">03. Counting Sort의 시간복잡도</h2>
<p><br /></p>

<p>     카운팅 정렬의 시간복잡도는 \(O(n+k)\)라고 하였다.  수열의 크기\((n)\)보다 정렬해야하는 수의 최대값\((k)\)이 크다면 시간이 비약적으로 증가한다. 이제 이 말이 무슨 의미인지 감이 잡힌다. 
<br /></p>

<p>     예를 들어 최대값이 1억이고 수열의 크기가 5인 수열이 있다고 가정해보자. 이 수열을 정렬해야 하는데 5개의 수를 정렬하기 위해 크기가 1억인 배열을 만들어야 한다.</p>
<blockquote>
  <p>수열의 크기보다 수의 최대값이 크면 배열의 크기가 쓸때없이 커져버리기 때문에 비효율적일 수밖에 없다.</p>
</blockquote>

<p>그에 비해 퀵 정렬은 수의 최대값에 영향을 받지도 않고, 추가적인 메모리 공간이 필요하지도 않기 때문에 정렬이 필요한 대부분의 상황에서 퀵 정렬을 사용하는 것이다.</p>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML">
</script>

:ET