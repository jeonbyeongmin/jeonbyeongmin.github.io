I"<blockquote>
  <h3 id="q1-메모리나-레지스터에-데이터가-표현되는-방식을-이해하는-것은-매우-중요하다-그-이유가-무엇일까">Q1. 메모리나, 레지스터에 데이터가 표현되는 방식을 이해하는 것은 매우 중요하다. 그 이유가 무엇일까?</h3>
  <p> 
     우리가 다루게 될 프로그램에서 어떻게 정수나 부동소수점을 컴퓨터가 처리하고 계산하는지 아는 것은 중요하다. 메모리 접근도 정수 연산을 통해서 이뤄지고, CPU의 레지스터에 어떻게 정수형이 저장되고 메모리 주소가 계산되는 지를 알아야 한다.</p>
</blockquote>

<p><br />
<br />
<br /></p>

<h1 id="--알아두면-좋은-지식들">✓   알아두면 좋은 지식들</h1>
<h3 id="1byte-는-8bits-이다">1byte 는 8bits 이다.</h3>
<p>  1바이트는 8개의 0이나 1로 표현할 수 있다는 뜻이다. ( bit : Binary Digit ) 가령, 8비트로 표현 가능한 수는 <strong>‘0000 0001’ 부터 ‘1111 1111’ 까지</strong>이다. 8비트를 10진수로 표현 가능한 수는 <strong>‘0’부터 ‘255’까지</strong>이다. 8비트를 16진수로 표현 가능한 수는 <strong>‘00’ 부터 ‘FF’ 까지</strong>이다.</p>

<h3 id="1word는-4byte-혹은-8byte-이다">1word는 4byte 혹은 8byte 이다.</h3>
<p>  일반적으로 주소는 메모리에서 워드의 첫 번째 바이트 위치의 값이다. 1워드씩 규칙적인 공간을 할당한 것이다. 따라서 메모리 주소는 1워드씩 증가하며 접근한다. 1워드씩 증가하는 이유는 이것이 메모리 관리를 하는 것에 굉장히 효율적이다. 일일이 앞에 있는 값들을 탐색해야 우리가 원하는 주소에 접근하는 것이 가능하기 때문에 1바이트씩 접근하는 것보다 4바이트씩 접근하는 것이 훨씬 빠른 것이다. C언어에서 포인터도 1워드를 사용한다.</p>
<blockquote>
  <p>만약 1word가 4byte인 컴퓨터에서 주소값은<span style="color:green"> 0000 0004 0008 0012</span> 와 같이 4byte씩 증가하는 것이다.</p>
</blockquote>

<p><br /></p>

<h3 id="lsb와-msb">LSB와 MSB</h3>
<p>  <strong>LSB는 ‘Least Significant Bit’의 약자이다.</strong> 즉 전체 비트에서 가장 작은 값을 가지는 비트에 해당하며 가장 오른쪽에 위치한다. 반면, <strong>MSB는 ‘Most Significant Bit’의 약자이다.</strong> 전체 비트에서 가장 큰 값을 가지는 비트에 해당하며 가장 왼쪽에 위치한다. 다만 대문자로 표기할 시에는 비트를 바이트로 바꾸어 말하기도 한다.</p>

<h3 id="byte-ordering--바이트-저장-순서">Byte Ordering :: 바이트 저장 순서</h3>
<p>  <strong>Big Endian</strong>과 <strong>Little Endian</strong>이 있다. Big Endian은 LSB가 최대 주소에 저장되며 디버깅에 용이한 반명 Little Endian은 LSB가 최소 주소에 저장되고 형 변환에 용이하다. 우리가 잘 아는 x86은 Little Endian에 해당한다.</p>
<blockquote>
  <p>가령 0x A0 B0 C0 <span style="color: blue">D0</span>이라는 값을 메모리에 저장할 때, Big Endian은 A0 B0 C0 <span style="color: blue">D0</span> 순서로 저장되고 Little Endian은 <span style="color: blue">D0</span> C0 B0 A0 순서로 저장된다.</p>
</blockquote>

<p><br />
<br /></p>

<p><br /></p>

<h1 id="--비트-수준-연산">✓   비트 수준 연산</h1>
<h3 id="-and">&amp; (AND)</h3>
<p>  첫 번째 비트와 두 번째 비트가 모두 ‘1’일 때에만 ‘1’을 갖는다.</p>

<p>x10     0000 <span style="color:red">11</span>01 1100 0000 <br />
x11     0011 <span style="color:red">11</span>00 0000 0000<br />
X9       0000 <span style="color:red">11</span>00 0000 0000</p>

<p><br /></p>

<h3 id="-or">| (OR)</h3>
<p>  첫 번째 비트와 두 번째 비트 둘 중에 하나라도 ‘1’을 가지고 있으면 ‘1’을 갖는다.</p>

<p>x10     0000 <span style="color:red">11</span>0<span style="color:red">1 11</span>00 0000<br />
x11     00<span style="color:red">11 11</span>00 0000 0000<br />
X9       00<span style="color:red">11 11</span>0<span style="color:red">1 11</span>00 0000</p>

<p><br /></p>

<h3 id="-xor">^ (XOR)</h3>
<p>  첫 번째 비트와 두 번째 비트의 값이 다르면 ‘1’을 갖는다.</p>

<p>x10     00<span style="color:red">00</span> 110<span style="color:red">1 11</span>00 0000<br />
x11     00<span style="color:red">11</span> 110<span style="color:red">0 00</span>00 0000<br />
X9       00<span style="color:red">11</span> 000<span style="color:red">1 11</span>00 0000</p>

<p><br /></p>

<h3 id="-not">~ (NOT)</h3>
<p>   비트 반전을 한다.</p>

<p>x10       0001 1010 0000 1111
x11       1110 0101 1111 0000</p>
:ET