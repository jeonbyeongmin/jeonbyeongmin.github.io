<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.1.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2020-10-04T15:24:56+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">JEON BYEONGMIN</title><subtitle>공부를 합시다</subtitle><author><name>전병민</name><email>qudals7613@gmail.com</email></author><entry><title type="html">비트와 바이트</title><link href="http://localhost:4000/Integer/" rel="alternate" type="text/html" title="비트와 바이트" /><published>2020-10-04T00:00:00+09:00</published><updated>2020-10-04T00:00:00+09:00</updated><id>http://localhost:4000/Integer</id><content type="html" xml:base="http://localhost:4000/Integer/">&lt;blockquote&gt;
  &lt;h3 id=&quot;q1-메모리나-레지스터에-데이터가-표현되는-방식을-이해하는-것은-매우-중요하다-그-이유가-무엇일까&quot;&gt;Q1. 메모리나, 레지스터에 데이터가 표현되는 방식을 이해하는 것은 매우 중요하다. 그 이유가 무엇일까?&lt;/h3&gt;
  &lt;p&gt; 
     우리가 다루게 될 프로그램에서 어떻게 정수나 부동소수점을 컴퓨터가 처리하고 계산하는지 아는 것은 중요하다. 메모리 접근도 정수 연산을 통해서 이뤄지고, CPU의 레지스터에 어떻게 정수형이 저장되고 메모리 주소가 계산되는 지를 알아야 한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;--알아두면-좋은-지식들&quot;&gt;✓   알아두면 좋은 지식들&lt;/h1&gt;
&lt;h3 id=&quot;1byte-는-8bits-이다&quot;&gt;1byte 는 8bits 이다.&lt;/h3&gt;
&lt;p&gt;  1바이트는 8개의 0이나 1로 표현할 수 있다는 뜻이다. ( bit : Binary Digit ) 가령, 8비트로 표현 가능한 수는 &lt;strong&gt;‘0000 0001’ 부터 ‘1111 1111’ 까지&lt;/strong&gt;이다. 8비트를 10진수로 표현 가능한 수는 &lt;strong&gt;‘0’부터 ‘255’까지&lt;/strong&gt;이다. 8비트를 16진수로 표현 가능한 수는 &lt;strong&gt;‘00’ 부터 ‘FF’ 까지&lt;/strong&gt;이다.&lt;/p&gt;

&lt;h3 id=&quot;1word는-4byte-혹은-8byte-이다&quot;&gt;1word는 4byte 혹은 8byte 이다.&lt;/h3&gt;
&lt;p&gt;  일반적으로 주소는 메모리에서 워드의 첫 번째 바이트 위치의 값이다. 1워드 씩 규칙적인 공간을 할당한 것이다. 따라서 메모리 주소는 1워드 씩 증가하며 접근한다. 1워드 씩 증가하는 이유는 이것이 메모리 관리를 하는 것에 굉장히 효율적이다. 일일이 앞에 있는 값들을 탐색해야 우리가 원하는 주소에 접근하는 것이 가능하기 때문에 1바이트 씩 접근하는 것보다 4바이트 씩 접근하는 것이 훨씬 빠른 것이다. C언어에서 포인터도 1워드를 사용한다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;만약 1word가 4byte인 컴퓨터에서 주소값은&lt;span style=&quot;color:green&quot;&gt; 0000 0004 0008 0012&lt;/span&gt; 와 같이 4byte씩 증가하는 것이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;lsb와-msb&quot;&gt;LSB와 MSB&lt;/h3&gt;
&lt;p&gt;  &lt;strong&gt;LSB는 ‘Least Significant Bit’의 약자이다.&lt;/strong&gt; 즉 전체 비트에서 가장 작은 값을 가지는 비트에 해당하며 가장 오른쪽에 위치한다. 반면, &lt;strong&gt;MSB는 ‘Most Significant Bit’의 약자이다.&lt;/strong&gt; 전체 비트에서 가장 큰 값을 가지는 비트에 해당하며 가장 왼쪽에 위치한다. 다만 대문자로 표기할 시에는 비트를 바이트로 바꾸어 말하기도 한다.&lt;/p&gt;

&lt;h3 id=&quot;byte-ordering--바이트-저장-순서&quot;&gt;Byte Ordering :: 바이트 저장 순서&lt;/h3&gt;
&lt;p&gt;  &lt;strong&gt;Big Endian&lt;/strong&gt;과 &lt;strong&gt;Little Endian&lt;/strong&gt;이 있다. Big Endian은 LSB가 최대 주소에 저장되며 디버깅에 용이한 반명 Little Endian은 LSB가 최소 주소에 저장되고 형 변환에 용이하다. 우리가 잘 아는 x86은 Little Endian에 해당한다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;가령 0x A0 B0 C0 &lt;span style=&quot;color: blue&quot;&gt;D0&lt;/span&gt;이라는 값을 메모리에 저장할 때, Big Endian은 A0 B0 C0 &lt;span style=&quot;color: blue&quot;&gt;D0&lt;/span&gt; 순서로 저장되고 Little Endian은 &lt;span style=&quot;color: blue&quot;&gt;D0&lt;/span&gt; C0 B0 A0 순서로 저장된다.&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name>전병민</name><email>qudals7613@gmail.com</email></author><summary type="html">Q1. 메모리나, 레지스터에 데이터가 표현되는 방식을 이해하는 것은 매우 중요하다. 그 이유가 무엇일까?       우리가 다루게 될 프로그램에서 어떻게 정수나 부동소수점을 컴퓨터가 처리하고 계산하는지 아는 것은 중요하다. 메모리 접근도 정수 연산을 통해서 이뤄지고, CPU의 레지스터에 어떻게 정수형이 저장되고 메모리 주소가 계산되는 지를 알아야 한다.</summary></entry></feed>