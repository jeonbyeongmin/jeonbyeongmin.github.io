var store = [{
        "title": "Merge Sort(합병 정렬)에 대해 설명해보겠다",
        "excerpt":"      간단한 알고리즘으로 구현할 수 있는 대표적인 정렬은 다음과 같다.       Insertion Sort – 삽입정렬   Selection Sort – 선택정렬   Bubble Sort – 버블정렬         버블정렬과 선택정렬은 모든 경우에 \\(O(n²)\\)시간이 걸리고 삽입정렬 또한 최악의 경우 \\(O(n²)\\)시간이 걸리기 때문에 매우 비효율적인 알고리즘이라는 것을 알 수 있다.          다음은 복잡한 알고리즘으로 구현할 수 있는 대표적인 정렬이다.       Quick Sort – 퀵정렬   Heap Sort – 힙정렬   Merge Sort – 합병정렬        힙정렬은 합병정렬과 마찬가지로 Binary Tree로 접근하는 알고리즘이기 때문에 모든 경우에 \\(O(nlogn)\\)시간이 걸린다. 실제 시간은 보통의 경우 다른 \\(O(nlogn)\\)정렬법들에 비해 오래 걸린다.       퀵정렬의 내부 루프는 대부분의 컴퓨터 아키텍처에서 효율적으로 작동하도록 설계되어 있다. 그 이유는 메모리 참조가 지역화되어 있기 때문에 CPU 캐시의 히트율이 높아지기 때문이다. 최악의 경우 \\(O(n²)\\)시간이 걸리지만, 대부분의 실질적인 데이터를 정렬할 때 제곱 시간이 걸릴 확률이 거의 없도록 알고리즘을 설계하는 것이 가능하다.       심지어 합병정렬은 추가적인 메모리가 필요하기 때문에 추가적인 메모리 할당이 불가능한 경우에는 합병정렬을 사용할 수 없다. 또한 배열을 생성하는 시간 때문에 보통 퀵정렬보다 느리다. 그래서 대부분의 상황에서 빠르고 추가 메모리 할당이 필요없는 퀵정렬을 사용한다.          아니 그렇다면 도대체 합병정렬을 왜 쓰는 것일까?       \t결론부터 말하자면, 합병정렬은 LinkedList 의 정렬을 구현할 때 퀵정렬보다 유용하다. 그 이유는 ArrayList 와 달리 LinkedList 는 접근 연산에서 head 부터 접근하기 때문에 퀵정렬과 같은 임의적인 접근은 오버헤드(Overhead)가 증가할 수밖에 없다. 자세한 내용은 이후 퀵정렬을 다루는 포스트에서 작성하도록 하겠다.     여하튼 그러한 이유로 지금은 합병정렬에 대해 설명해보겠다.           01. Merge Sort 의 개념과 작동과정         합병정렬은 분할정복(Divide and Conquer)의 대표적인 알고리즘이다. 분할정복은 그대로 해결할 수 없는 문제를 작은 문제로 분할하여 문제를 해결하는 방법이나 알고리즘이다. 보통은 재귀함수(Recursive function)를 이용하여 구현한다.          합병정렬은 다음과 같이 작동한다.              리스트의 길이가 1 이하라면 이미 정렬된 것으로 본다. 그렇지 않은 경우에는   분할(Divide) : 정렬되지 않은 리스트를 절반으로 잘라 비슷한 크기의 두 부분 리스트로 나눈다.   정복(Conquer) : 각 부분 리스트를 재귀적으로 합병 정렬을 이용해 정렬한다.   결합(Combine) : 두 부분 리스트를 다시 하나의 정렬된 리스트로 합병한다. 이때 정렬 결과가 임시배열에 저장된다.   복사(Copy) : 임시 배열에 저장된 결과를 원래 배열에 복사한다.        02.  Merge Sort의  JAVA 소스코드      public static int[] src; public static int[] temp; public static void mergeSort(int start, int end){         if (start &lt; end){              int mid = (start+end) / 2;             mergeSort(start, mid);             mergeSort(mid+1, end);              int p = start;             int q = mid + 1;              int idx = p;              while (p &lt;= mid || q &lt;= end){                  if (q &gt; end || (p &lt;= mid &amp;&amp; src[p] &lt; src[q])){                      temp[idx++] = src[p++];                 } else{                     temp[idx++] = src[q++];                 }             }              for (int i = start; i &lt;= end; i++){                 src[i] = temp[i];             }         }     }      먼저 mergeSort()의 전체 코드를 보자. 이제 코드 하나하나 뜯어보겠다.                     int mid = (start+end) / 2;             mergeSort(start, mid);             mergeSort(mid+1, end);      재귀함수(Recursive function)를 사용하는 부분이다. 정렬되지 않은 리스트를 절반으로 잘라 비슷한 크기의 두 부분 리스트로 나눈다. 리스트의 길이가 1 이하가 될 때까지 반복한다.     즉, 더이상 리스트를 분할할 수 없을 때까지 계속 두 부분으로 나눈다.                      int p = start;             int q = mid + 1;             int idx = p;     분할된 두 리스트의 첫 번째 인덱스(Index)를 p와 q에 저장해줄 것이다. 리스트를 분할한다고 표현한 것이 바로 이 인덱스를 가리키며 한 말이다. 재귀함수이기 때문에 자기 자신을 계속 반복하며 p나 q에 할당되는 숫자가 달라진다. 이때 p와 q를 통해 이후에 나올 코드에서 정복(Conquer), 결합(Combine), 복사(Copy)를 할 수 있다.       여기서 int idx = p;를 해주는 것은 두 리스트를 합병하기 위해 만들어진 리스트 temp[]의 인덱스 계산을 위해 필요하기 때문이다. 바로 아래의 코드를 참고하자.                      while (p &lt;= mid || q &lt;= end){                 if (q &gt; end || (p &lt;= mid &amp;&amp; src[p] &lt; src[q])){                     temp[idx++] = src[p++];                 } else{                     temp[idx++] = src[q++];                 }     while문의 조건에 (p &lt;= mid || q &lt;= end)이 들어가는 이유는 다음과 같다.          분할된 두 리스트의 마지막 인덱스는 각각 mid와 end이다.     &lt;이 아니라 &lt;=인 것은 리스트이 요소가 하나일 때에도 while문을 돌려주기 위함이다.     &amp;&amp;이 아니라 ||인 것은 둘 중에 하나라도 끝이 나지 않았다면 while문을 돌려주어야 하기 때문이다.         이제 분할된 두 개의 리스트에서 각각의 요소를 비교하여 temp[]에 넣어줄 것이다. if문에 조건으로 들어가는 q &gt; end는 q에서 더이상 가져올 요소가 없다는 뜻이며, (p &lt;= mid &amp;&amp; src[p] &lt; src[q])는 p에서 가져올 요소가 존재할 때, 두 리스트의 요소 중 더 작은 것을 temp[]에 넣어주기 위함이다.          if문 안에서 요소를 temp[]로 가져올 때마다 q++을 하기 때문에, q &gt; end 라는 것이 곧 q에서 가져올 요소가 없다는 뜻이다.     else는 반대의 경우이다.     q &gt; end와 (p &lt;= mid &amp;&amp; src[p] &lt; src[q])를 &amp;&amp;이 아니라 ||로 묶어주는 것은 q에서 가져올 것이 없으면 무조건 p에서 가져와야 하기 때문이다.                        for (int i = start; i &lt;= end; i++){                 src[i] = temp[i];             }     이제 temp[]에 저장된 요소들을 다시 src[]에 가져오면 된다.     while문에서 idx로 인덱스 계산을 해주었기 때문에 src[]로 가져올 때는 따로 계산없이 그대로 가져와야 한다.          03. Merge Sort의 시간복잡도         합병정렬은 Binary Tree형태로 분할하기 때문에 가질수 있는 최대 깊이는 \\(logn\\)이 된다. 이때, 각 분할 별로 합병을 진행하기 때문에 총 시간복잡도는 \\(O(nlogn)\\)이 된다. 다음 그림을 참고하도록 하자.          ","categories": [],
        "tags": [],
        "url": "http://localhost:4000/java-merge-sort/",
        "teaser": null
      },{
        "title": "Counting Sort(카운팅 정렬)에 대해 설명해보겠다.",
        "excerpt":"        정렬에 대한 알고리즘은 다양하다. 빠른 속도를 보여주는 정렬은 \\(O(nlogn)\\)시간이 걸리는 퀵 정렬 (Quick Sort), 힙 정렬 (Heap Sort), 합병 정렬 (Merge Sort)이 있고, 그 중에서 대부분의 경우에 퀵 정렬을 쓴다고 소개했었다.          하지만 오늘 설명할  카운팅 정렬 (Counting Sort)의 시간복잡도는 \\(O(n+k)\\)이며 \\(n &gt; k\\)인 경우에는 퀵 정렬보다 훨씬 빠른 성능을 자랑한다.         그럼 왜 대부분의 경우에서 퀵 정렬을 사용할까       카운팅 정렬은 추가적인 메모리 할당이 필요하다.   정렬해야하는 수의 범위를 모른다면 사용하기가 곤란하다.   수열의 크기\\((n)\\)보다 정렬해야하는 수의 최대값\\((k)\\)의 가 크다면 시간이 비약적으로 증가한다.       01. Counting Sort의 개념과 동작과정          보통 정렬을 할 때에는 비교를 하기 마련이다. 합병 정렬도 그렇고, 퀵 정렬도 그렇고, 힙 정렬도 마찬가지이다. 이런 비교 기반 정렬법들은 어지간하면 시간 복잡도가 \\(O(nlogn)\\)보다 짧아지기가 어려운데, 카운팅 정렬은 \\(O(n+k)\\)이다. 이게 어떻게 된 일일까.      Counting Sort는 비교 기반 정렬이 아니다.        카운팅 정렬은 기본적으로 비교 연산이 들어가는 정렬이 아니다. 카운팅 정렬의 동작 과정을 보며 카운팅 정렬의 정렬 방법을 알아보자. (변수의 이름은 밑의 애니메이션의 변수와 같으니 애니메이션을 참고하자)     먼저 카운팅 정렬은 수를 세주는 배열 c[]가 필요하다. 정렬이 필요한 배열 a[]의 각 index를 방문하여 a[index] = k일때  c[k]++를 해주어 k가 몇 번 반복되었는 지 세줄 것이다.   실제 정렬을 했을 때 그 숫자가 처음 시작하는 index를 알기 위하여 c[i] = c[i] + c[i-1]를 통해 카운트의 누적합을 적용한다.   이제 a[]를 아래 애니메이션과 같은 과정으로 b[]에 정렬해줄 것이다.          02. Counting Sort JAVA 소스코드      변수의 이름은 위 설명의 변수와 같으니 설명과 애니메이션을 참고하자   public static void main(String[] args){          int a[] = new int[10];         int c[] = new int[20];         int b[] = new int[a.length];          for(int i = 0; i &lt; a.length; i++) { // 00. a에 랜덤 원소 할당             a[i] = (int)(Math.random()*20);         }          for (int i = 0; i &lt; a.length; i++) { // 01. 카운팅            c[a[i]]++;         } \t\t\t\t         for (int i = 1; i &lt; c.length; i++){ // 02. 카운트 누적합            c[i] = c[i] + c[i-1];         } \t\t\t\t         for (int i = a.length-1; i &gt;= 0; i--){ // 03. 누적합를 통해 실질적인 정렬을 담당            c[a[i]]--;            b[c[a[i]]] = a[i];         }           // 출력         for (int i = 0; i &lt; a.length; i++){             System.out.print(\" | \" + a[i]);         }         System.out.println();         for (int i = 0; i &lt; b.length; i++){             System.out.print(\" | \" + b[i]);         } }       만약 단순히 정렬된 출력이 필요하다면 2번, 3번, 출력 부분을 생략하고 다음과 같은 코드로 대신하여도 된다.           for (int i = 0; i &lt; c.length; i++){             while(c[i] &gt; 0){                 System.out.println(i);                 count[i]--;             }         }      03. Counting Sort의 시간복잡도           카운팅 정렬의 시간복잡도는 \\(O(n+k)\\)라고 하였다.  수열의 크기\\((n)\\)보다 정렬해야하는 수의 최대값\\((k)\\)이 크다면 시간이 비약적으로 증가한다. 이제 이 말이 무슨 의미인지 감이 잡힌다.           예를 들어 최대값이 1억이고 수열의 크기가 5인 수열이 있다고 가정해보자. 이 수열을 정렬해야 하는데 5개의 수를 정렬하기 위해 크기가 1억인 배열을 만들어야 한다.     수열의 크기보다 수의 최대값이 크면 배열의 크기가 쓸때없이 커져버리기 때문에 비효율적일 수밖에 없다.         그에 비해 퀵 정렬은 수의 최대값에 영향을 받지도 않고, 추가적인 메모리 공간이 필요하지도 않기 때문에 정렬이 필요한 대부분의 상황에서 퀵 정렬을 사용하는 것이다.     ","categories": [],
        "tags": [],
        "url": "http://localhost:4000/counting-sort/",
        "teaser": null
      }]
